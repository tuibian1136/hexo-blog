<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Matery</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-09-26T02:43:49.788Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>何峰</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker</title>
    <link href="http://example.com/2020/09/28/docker/"/>
    <id>http://example.com/2020/09/28/docker/</id>
    <published>2020-09-28T03:55:50.162Z</published>
    <updated>2020-09-26T02:43:49.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>学习目标：</p><ul><li><p>掌握Docker基础知识，能够理解Docker镜像与容器的概念</p></li><li><p>完成Docker安装与启动</p></li><li><p>掌握Docker镜像与容器相关命令</p></li><li><p>掌握Tomcat Nginx 等软件的常用应用的安装</p></li><li><p>掌握docker迁移与备份相关命令</p></li><li><p>能够运用Dockerfile编写创建容器的脚本</p></li><li><p>能够搭建与使用docker私有仓库</p></li></ul><h1 id="1-Docker简介"><a href="#1-Docker简介" class="headerlink" title="1 Docker简介"></a>1 Docker简介</h1><h2 id="1-1-什么是虚拟化"><a href="#1-1-什么是虚拟化" class="headerlink" title="1.1 什么是虚拟化"></a>1.1 什么是虚拟化</h2><p>​    在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。</p><p>​    在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件&nbsp;&nbsp; 对资源充分利用</p><p>​    虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。</p><h2 id="1-2-什么是Docker"><a href="#1-2-什么是Docker" class="headerlink" title="1.2 什么是Docker"></a>1.2 什么是Docker</h2><p>​    Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在&nbsp;<a href="https://github.com/docker/docker">GitHub</a>&nbsp;上进行维护。</p><p>​    <img src="image/1-3.png"></p><p>​    Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。</p><p>​    Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。</p><p>​    在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。</p><p>为什么选择Docker?</p><p>（1）上手快。</p><p>​    用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。    </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。</p><p>（2）职责的逻辑分类</p><p>​    使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）”</p><p>（3）快速高效的开发生命周期</p><p>​    Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。）</p><p>（4）鼓励使用面向服务的架构</p><p>​    Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序）</p><h2 id="1-3-容器与虚拟机比较"><a href="#1-3-容器与虚拟机比较" class="headerlink" title="1.3 容器与虚拟机比较"></a>1.3 容器与虚拟机比较</h2><p>​    下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。</p><p><img src="image/1-1.png"></p><p>与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。</p><h2 id="1-4-Docker-组件"><a href="#1-4-Docker-组件" class="headerlink" title="1.4 Docker 组件"></a>1.4 Docker 组件</h2><h3 id="1-4-1-Docker服务器与客户端"><a href="#1-4-1-Docker服务器与客户端" class="headerlink" title="1.4.1 Docker服务器与客户端"></a>1.4.1 Docker服务器与客户端</h3><p>​    Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。</p><p><img src="image/1-2.png"></p><h3 id="1-4-2-Docker镜像与容器"><a href="#1-4-2-Docker镜像与容器" class="headerlink" title="1.4.2 Docker镜像与容器"></a>1.4.2 Docker镜像与容器</h3><p>​    镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。例如：</p><p>添加一个文件；</p><p>执行一个命令；</p><p>打开一个窗口。</p><p>也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。</p><p>​    Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。&nbsp; 容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。</p><p>所以Docker容器就是：</p><p>​    一个镜像格式；</p><p>​    一些列标准操作；</p><p>​    一个执行环境。</p><p>​    Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 和集装箱一样，Docker在执行上述操作时，并不关心容器中到底装了什么，它不管是web服务器，还是数据库，或者是应用程序服务器什么的。所有的容器都按照相同的方式将内容“装载”进去。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Docker也不关心你要把容器运到何方：我们可以在自己的笔记本中构建容器，上传到Registry，然后下载到一个物理的或者虚拟的服务器来测试，在把容器部署到具体的主机中。像标准集装箱一样，Docker容器方便替换，可以叠加，易于分发，并且尽量通用。</p><h3 id="1-4-3-Registry（注册中心）"><a href="#1-4-3-Registry（注册中心）" class="headerlink" title="1.4.3 Registry（注册中心）"></a>1.4.3 Registry（注册中心）</h3><p>​    Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。</p><p>​    <a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h1 id="2-Docker安装与启动"><a href="#2-Docker安装与启动" class="headerlink" title="2 Docker安装与启动"></a>2 Docker安装与启动</h1><h2 id="2-1-安装Docker"><a href="#2-1-安装Docker" class="headerlink" title="2.1 安装Docker"></a>2.1 安装Docker</h2><p>​    Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。</p><p>​    由于我们学习的环境都使用的是CentOS，因此这里我们将Docker安装到CentOS上。注意：这里建议安装在CentOS7.x以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更新。</p><p>​    请直接挂载课程配套的Centos7.x镜像    </p><p>（1）yum 包更新到最新</p><pre><code>sudo yum update</code></pre><p>（2）安装需要的软件包，&nbsp;yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p><pre><code>sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code></pre><p>（3）设置yum源为阿里云</p><pre><code>sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre><p>（4）安装docker</p><pre><code>sudo yum install docker-ce</code></pre><p>（5）安装后查看docker版本</p><pre><code>docker -v</code></pre><h2 id="2-2-设置ustc的镜像"><a href="#2-2-设置ustc的镜像" class="headerlink" title="2.2 设置ustc的镜像"></a>2.2 设置ustc的镜像</h2><p>ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。</p><p><a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker">https://lug.ustc.edu.cn/wiki/mirrors/help/docker</a></p><p>编辑该文件：</p><pre><code>vi /etc/docker/daemon.json&nbsp; </code></pre><p>在该文件中输入如下内容：</p><pre><code>{"registry-mirrors": ["https://docker.mirrors.ustc.edu.cn"]}</code></pre><h2 id="2-3-Docker的启动与停止"><a href="#2-3-Docker的启动与停止" class="headerlink" title="2.3 Docker的启动与停止"></a>2.3 Docker的启动与停止</h2><p><strong>systemctl</strong>命令是系统服务管理器指令</p><p>启动docker：</p><pre><code>systemctl start&nbsp;docker</code></pre><p>停止docker：</p><pre><code>systemctl stop&nbsp;docker</code></pre><p>重启docker：</p><pre><code>systemctl restart&nbsp;docker</code></pre><p>查看docker状态：</p><pre><code>systemctl status&nbsp;docker</code></pre><p>开机启动：</p><pre><code>systemctl enable docker</code></pre><p>查看docker概要信息</p><pre><code>docker info</code></pre><p>查看docker帮助文档</p><pre><code>docker --help</code></pre><h1 id="3-常用命令"><a href="#3-常用命令" class="headerlink" title="3 常用命令"></a>3 常用命令</h1><h2 id="3-1-镜像相关命令"><a href="#3-1-镜像相关命令" class="headerlink" title="3.1 镜像相关命令"></a>3.1 镜像相关命令</h2><h3 id="3-1-1-查看镜像"><a href="#3-1-1-查看镜像" class="headerlink" title="3.1.1 查看镜像"></a>3.1.1 查看镜像</h3><pre><code>docker images</code></pre><p>REPOSITORY：镜像名称</p><p>TAG：镜像标签</p><p>IMAGE ID：镜像ID</p><p>CREATED：镜像的创建日期（不是获取该镜像的日期）</p><p>SIZE：镜像大小</p><p>这些镜像都是存储在Docker宿主机的/var/lib/docker目录下</p><h3 id="3-1-2-搜索镜像"><a href="#3-1-2-搜索镜像" class="headerlink" title="3.1.2 搜索镜像"></a>3.1.2 搜索镜像</h3><p>如果你需要从网络中查找需要的镜像，可以通过以下命令搜索</p><pre><code>docker search 镜像名称</code></pre><p>NAME：仓库名称</p><p>DESCRIPTION：镜像描述</p><p>STARS：用户评价，反应一个镜像的受欢迎程度</p><p>OFFICIAL：是否官方</p><p>AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的</p><h3 id="3-1-3-拉取镜像"><a href="#3-1-3-拉取镜像" class="headerlink" title="3.1.3 拉取镜像"></a>3.1.3 拉取镜像</h3><p>拉取镜像就是从中央仓库中下载镜像到本地</p><pre><code>docker pull 镜像名称</code></pre><p>例如，我要下载centos7镜像</p><pre><code>docker pull centos:7</code></pre><h3 id="3-1-4-删除镜像"><a href="#3-1-4-删除镜像" class="headerlink" title="3.1.4 删除镜像"></a>3.1.4 删除镜像</h3><p>按镜像ID删除镜像</p><pre><code>docker rmi 镜像ID</code></pre><p>删除所有镜像</p><pre><code>docker rmi `docker images -q`</code></pre><h2 id="3-2-容器相关命令"><a href="#3-2-容器相关命令" class="headerlink" title="3.2 容器相关命令"></a>3.2 容器相关命令</h2><h3 id="3-2-1-查看容器"><a href="#3-2-1-查看容器" class="headerlink" title="3.2.1 查看容器"></a>3.2.1 查看容器</h3><p>查看正在运行的容器</p><pre><code>docker ps</code></pre><p>查看所有容器</p><pre><code>docker ps –a</code></pre><p>查看最后一次运行的容器</p><pre><code>docker ps –l</code></pre><p>查看停止的容器</p><pre><code>docker ps -f status=exited</code></pre><h3 id="3-2-2-创建与启动容器"><a href="#3-2-2-创建与启动容器" class="headerlink" title="3.2.2 创建与启动容器"></a>3.2.2 创建与启动容器</h3><p>创建容器常用的参数说明：</p><p>创建容器命令：docker run</p><p> -i：表示运行容器</p><p> -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。</p><p> –name :为创建的容器命名。</p><p> -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。</p><p> -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。</p><p> -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射</p><p>（1）交互式方式创建容器</p><pre><code>docker run -it --name=容器名称 镜像名称:标签 /bin/bash</code></pre><p>这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态  </p><p>退出当前容器</p><pre><code>exit</code></pre><p>（2）守护式方式创建容器：</p><pre><code>docker run -di --name=容器名称 镜像名称:标签</code></pre><p>登录守护式容器方式：</p><pre><code>docker exec -it 容器名称 (或者容器ID)  /bin/bash</code></pre><h3 id="3-2-3-停止与启动容器"><a href="#3-2-3-停止与启动容器" class="headerlink" title="3.2.3 停止与启动容器"></a>3.2.3 停止与启动容器</h3><p>停止容器：</p><pre><code>docker stop 容器名称（或者容器ID）</code></pre><p>启动容器：</p><pre><code>docker start 容器名称（或者容器ID）</code></pre><h3 id="3-2-4-文件拷贝"><a href="#3-2-4-文件拷贝" class="headerlink" title="3.2.4 文件拷贝"></a>3.2.4 文件拷贝</h3><p>如果我们需要将文件拷贝到容器内可以使用cp命令</p><pre><code>docker cp 需要拷贝的文件或目录 容器名称:容器目录</code></pre><p>也可以将文件从容器内拷贝出来</p><pre><code>docker cp 容器名称:容器目录 需要拷贝的文件或目录</code></pre><h3 id="3-2-5-目录挂载"><a href="#3-2-5-目录挂载" class="headerlink" title="3.2.5 目录挂载"></a>3.2.5 目录挂载</h3><p>我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。<br>创建容器 添加-v参数 后边为   宿主机目录:容器目录，例如：</p><pre><code>docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7</code></pre><p>如果你共享的是多级的目录，可能会出现权限不足的提示。</p><p>这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数  –privileged=true  来解决挂载的目录没有权限的问题</p><h3 id="3-2-6-查看容器IP地址"><a href="#3-2-6-查看容器IP地址" class="headerlink" title="3.2.6 查看容器IP地址"></a>3.2.6 查看容器IP地址</h3><p>我们可以通过以下命令查看容器运行的各种数据</p><pre><code>docker inspect 容器名称（容器ID）&nbsp;</code></pre><p>也可以直接执行下面的命令直接输出IP地址</p><pre><code>docker inspect --format='{{.NetworkSettings.IPAddress}}' 容器名称（容器ID）</code></pre><h3 id="3-2-7-删除容器"><a href="#3-2-7-删除容器" class="headerlink" title="3.2.7 删除容器"></a>3.2.7 删除容器</h3><p>删除指定的容器：</p><pre><code>docker rm 容器名称（容器ID）</code></pre><h1 id="4-应用部署"><a href="#4-应用部署" class="headerlink" title="4 应用部署"></a>4 应用部署</h1><h2 id="4-1-MySQL部署"><a href="#4-1-MySQL部署" class="headerlink" title="4.1 MySQL部署"></a>4.1 MySQL部署</h2><p>（1）拉取mysql镜像</p><pre><code>docker pull centos/mysql-57-centos7</code></pre><p>（2）创建容器</p><pre><code>docker run -di --name=tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql</code></pre><p>-p 代表端口映射，格式为&nbsp; 宿主机映射端口:容器运行端口</p><p>-e 代表添加环境变量&nbsp; MYSQL_ROOT_PASSWORD  是root用户的登陆密码</p><p>（3）远程登录mysql</p><p>连接宿主机的IP  ,指定端口为33306 </p><h2 id="4-2-tomcat部署"><a href="#4-2-tomcat部署" class="headerlink" title="4.2 tomcat部署"></a>4.2 tomcat部署</h2><p>（1）拉取镜像</p><pre><code>docker pull tomcat:7-jre7</code></pre><p>（2）创建容器</p><p>创建容器&nbsp; -p表示地址映射</p><pre><code>docker run -di --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7</code></pre><h2 id="4-3-Nginx部署"><a href="#4-3-Nginx部署" class="headerlink" title="4.3 Nginx部署"></a>4.3 Nginx部署</h2><p>（1）拉取镜像    </p><pre><code>docker pull nginx</code></pre><p>（2）创建Nginx容器</p><pre><code>docker run -di --name=mynginx -p 80:80 nginx</code></pre><h2 id="4-4-Redis部署"><a href="#4-4-Redis部署" class="headerlink" title="4.4 Redis部署"></a>4.4 Redis部署</h2><p>（1）拉取镜像</p><pre><code>docker pull redis</code></pre><p>（2）创建容器</p><pre><code>docker run -di --name=myredis -p 6379:6379 redis</code></pre><h1 id="5-迁移与备份"><a href="#5-迁移与备份" class="headerlink" title="5 迁移与备份"></a>5 迁移与备份</h1><h2 id="5-1-容器保存为镜像"><a href="#5-1-容器保存为镜像" class="headerlink" title="5.1 容器保存为镜像"></a>5.1 容器保存为镜像</h2><p>我们可以通过以下命令将容器保存为镜像</p><pre><code>docker commit mynginx mynginx_i</code></pre><h2 id="5-2-镜像备份"><a href="#5-2-镜像备份" class="headerlink" title="5.2 镜像备份"></a>5.2 镜像备份</h2><p>我们可以通过以下命令将镜像保存为tar 文件</p><pre><code>docker  save -o mynginx.tar mynginx_i</code></pre><h2 id="5-3-镜像恢复与迁移"><a href="#5-3-镜像恢复与迁移" class="headerlink" title="5.3 镜像恢复与迁移"></a>5.3 镜像恢复与迁移</h2><p>首先我们先删除掉mynginx_img镜像  然后执行此命令进行恢复</p><pre><code>docker load -i mynginx.tar</code></pre><p>-i 输入的文件</p><p>执行后再次查看镜像，可以看到镜像已经恢复</p><h1 id="6-Dockerfile"><a href="#6-Dockerfile" class="headerlink" title="6 Dockerfile"></a>6 Dockerfile</h1><h2 id="6-1-什么是Dockerfile"><a href="#6-1-什么是Dockerfile" class="headerlink" title="6.1 什么是Dockerfile"></a>6.1 什么是Dockerfile</h2><p>Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。</p><p>1、对于开发人员：可以为开发团队提供一个完全一致的开发环境；<br>2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了；<br>3、对于运维人员：在部署时，可以实现应用的无缝移植。</p><h2 id="6-2-常用命令"><a href="#6-2-常用命令" class="headerlink" title="6.2 常用命令"></a>6.2 常用命令</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>FROM image_name:tag</td><td>定义了使用哪个基础镜像启动构建流程</td></tr><tr><td>MAINTAINER user_name</td><td>声明镜像的创建者</td></tr><tr><td>ENV key value</td><td>设置环境变量 (可以写多条)</td></tr><tr><td>RUN command</td><td>是Dockerfile的核心部分(可以写多条)</td></tr><tr><td>ADD source_dir/file dest_dir/file</td><td>将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压</td></tr><tr><td>COPY source_dir/file dest_dir/file</td><td>和ADD相似，但是如果有压缩文件并不能解压</td></tr><tr><td>WORKDIR path_dir</td><td>设置工作目录</td></tr></tbody></table><h2 id="6-3-使用脚本创建镜像"><a href="#6-3-使用脚本创建镜像" class="headerlink" title="6.3 使用脚本创建镜像"></a>6.3 使用脚本创建镜像</h2><p>步骤：</p><p>（1）创建目录</p><pre><code>mkdir –p /usr/local/dockerjdk8</code></pre><p>（2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录</p><p>（3）创建文件Dockerfile  <code>vi Dockerfile</code></p><pre><code>#依赖镜像名称和IDFROM centos:7#指定镜像创建者信息MAINTAINER ITCAST#切换工作目录WORKDIR /usrRUN mkdir  /usr/local/java#ADD 是相对路径jar,把java添加到容器中ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/#配置java环境变量ENV JAVA_HOME /usr/local/java/jdk1.8.0_171ENV JRE_HOME $JAVA_HOME/jreENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATHENV PATH $JAVA_HOME/bin:$PATH</code></pre><p>（4）执行命令构建镜像</p><pre><code>docker build -t='jdk1.8' .</code></pre><p>注意后边的空格和点，不要省略</p><p>（5）查看镜像是否建立完成</p><pre><code>docker images</code></pre><h1 id="7-Docker私有仓库"><a href="#7-Docker私有仓库" class="headerlink" title="7 Docker私有仓库"></a>7 Docker私有仓库</h1><h2 id="7-1-私有仓库搭建与配置"><a href="#7-1-私有仓库搭建与配置" class="headerlink" title="7.1 私有仓库搭建与配置"></a>7.1 私有仓库搭建与配置</h2><p>（1）拉取私有仓库镜像（此步省略）</p><pre><code>docker pull registry</code></pre><p>（2）启动私有仓库容器</p><pre><code>docker run -di --name=registry -p 5000:5000 registry</code></pre><p>（3）打开浏览器 输入地址<a href="http://192.168.184.141:5000/v2/_catalog%E7%9C%8B%E5%88%B0%60%7B&quot;repositories&quot;:[]%7D%60">http://192.168.184.141:5000/v2/_catalog看到`{"repositories":[]}`</a> 表示私有仓库搭建成功并且内容为空</p><p>（4）修改daemon.json</p><pre><code>vi /etc/docker/daemon.json</code></pre><p>添加以下内容，保存退出。</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"insecure-registries"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"192.168.184.141:5000"</span><span class="token punctuation">]</span><span class="token punctuation">}</span> </code></pre><p>此步用于让 docker信任私有仓库地址</p><p>（5）重启docker 服务</p><pre><code>systemctl restart docker</code></pre><h2 id="7-2-镜像上传至私有仓库"><a href="#7-2-镜像上传至私有仓库" class="headerlink" title="7.2 镜像上传至私有仓库"></a>7.2 镜像上传至私有仓库</h2><p>（1）标记此镜像为私有仓库的镜像</p><pre><code>docker tag jdk1.8 192.168.184.141:5000/jdk1.8</code></pre><p>（2）再次启动私服容器</p><pre><code>docker start registry</code></pre><p>（3）上传标记的镜像</p><pre><code>docker push 192.168.184.141:5000/jdk1.8</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <summary type="html">Docker的学习</summary>
    
    
    
    <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="运维" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="容器" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch第一天1136</title>
    <link href="http://example.com/2020/09/28/elasticsearch-di-yi-tian-99/"/>
    <id>http://example.com/2020/09/28/elasticsearch-di-yi-tian-99/</id>
    <published>2020-09-28T03:55:50.157Z</published>
    <updated>2020-09-26T06:49:56.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch第一天"><a href="#ElasticSearch第一天" class="headerlink" title="ElasticSearch第一天"></a>ElasticSearch第一天</h1><h2 id="学习目标："><a href="#学习目标：" class="headerlink" title="学习目标："></a>学习目标：</h2><ol><li>能够理解ElasticSearch的作用</li><li>能够安装ElasticSearch服务</li><li>能够理解ElasticSearch的相关概念</li><li>能够使用Postman发送Restful请求操作ElasticSearch</li><li>能够理解分词器的作用</li><li>能够使用ElasticSearch集成IK分词器</li><li>能够完成es集群搭建</li></ol><h1 id="第一章-ElasticSearch简介"><a href="#第一章-ElasticSearch简介" class="headerlink" title="第一章 ElasticSearch简介"></a>第一章 ElasticSearch简介</h1><h2 id="1-1-什么是ElasticSearch"><a href="#1-1-什么是ElasticSearch" class="headerlink" title="1.1 什么是ElasticSearch"></a>1.1 什么是ElasticSearch</h2><p>Elaticsearch，简称为es， es是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。es也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p><h2 id="1-2-ElasticSearch的使用案例"><a href="#1-2-ElasticSearch的使用案例" class="headerlink" title="1.2 ElasticSearch的使用案例"></a>1.2 ElasticSearch的使用案例</h2><ul><li>2013年初，GitHub抛弃了Solr，采取ElasticSearch 来做PB级的搜索。 “GitHub使用ElasticSearch搜索20TB的数据，包括13亿文件和1300亿行代码”</li><li>维基百科：启动以elasticsearch为基础的核心搜索架构</li><li>SoundCloud：“SoundCloud使用ElasticSearch为1.8亿用户提供即时而精准的音乐搜索服务”</li><li>百度：百度目前广泛使用ElasticSearch作为文本数据分析，采集百度所有服务器上的各类指标数据及用户自定义数据，通过对各种数据进行多维分析展示，辅助定位分析实例异常或业务层面异常。目前覆盖百度内部20多个业务线（包括casio、云分析、网盟、预测、文库、直达号、钱包、风控等），单集群最大100台机器，200个ES节点，每天导入30TB+数据</li><li>新浪使用ES 分析处理32亿条实时日志</li><li>阿里使用ES 构建挖财自己的日志采集和分析体系</li></ul><h2 id="1-3-ElasticSearch对比Solr"><a href="#1-3-ElasticSearch对比Solr" class="headerlink" title="1.3 ElasticSearch对比Solr"></a>1.3 ElasticSearch对比Solr</h2><ul><li>Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能;</li><li>Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式；</li><li>Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供；</li><li>Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch</li></ul><h1 id="第二章-ElasticSearch安装与启动"><a href="#第二章-ElasticSearch安装与启动" class="headerlink" title="第二章 ElasticSearch安装与启动"></a>第二章 ElasticSearch安装与启动</h1><h2 id="2-1-下载ES压缩包"><a href="#2-1-下载ES压缩包" class="headerlink" title="2.1 下载ES压缩包"></a>2.1 下载ES压缩包</h2><p>ElasticSearch分为Linux和Window版本，基于我们主要学习的是ElasticSearch的Java客户端的使用，所以我们课程中使用的是安装较为简便的Window版本，项目上线后，公司的运维人员会安装Linux版的ES供我们连接使用。</p><p>ElasticSearch的官方地址： <a href="https://www.elastic.co/products/elasticsearch">https://www.elastic.co/products/elasticsearch</a></p><p><img src="image%5C1.png"></p><p><img src="image%5C2.png"></p><p><img src="image%5C7.png"></p><p><img src="image%5C8.png"></p><p>在资料中已经提供了下载好的5.6.8的压缩包：</p><p><img src="image%5C4.png"></p><h2 id="2-2-安装ES服务"><a href="#2-2-安装ES服务" class="headerlink" title="2.2 安装ES服务"></a>2.2 安装ES服务</h2><p>Window版的ElasticSearch的安装很简单，类似Window版的Tomcat，解压开即安装完毕，解压后的ElasticSearch的目录结构如下：</p><p><img src="image%5C5.png"></p><p>修改elasticsearch配置文件：config/elasticsearch.yml，增加以下两句命令：</p><pre><code>http.cors.enabled: truehttp.cors.allow-origin: "*"</code></pre><p>此步为允许elasticsearch跨越访问，如果不安装后面的elasticsearch-head是可以不修改，直接启动。</p><h2 id="2-3-启动ES服务"><a href="#2-3-启动ES服务" class="headerlink" title="2.3 启动ES服务"></a>2.3 启动ES服务</h2><p>点击ElasticSearch下的bin目录下的elasticsearch.bat启动，控制台显示的日志信息如下：</p><p><img src="image%5C6.png"></p><p><img src="image%5C9.png"></p><p>注意：9300是tcp通讯端口，集群间和TCPClient都执行该端口，9200是http协议的RESTful接口 。</p><p>通过浏览器访问ElasticSearch服务器，看到如下返回的json信息，代表服务启动成功：</p><p><img src="image%5C10.png"></p><pre><code>注意：ElasticSearch是使用java开发的，且本版本的es需要的jdk版本要是1.8以上，所以安装ElasticSearch之前保证JDK1.8+安装完毕，并正确的配置好JDK环境变量，否则启动ElasticSearch失败。</code></pre><h2 id="2-4-安装ES的图形化界面插件"><a href="#2-4-安装ES的图形化界面插件" class="headerlink" title="2.4 安装ES的图形化界面插件"></a>2.4 安装ES的图形化界面插件</h2><p>ElasticSearch不同于Solr自带图形化界面，我们可以通过安装ElasticSearch的head插件，完成图形化界面的效果，完成索引数据的查看。安装插件的方式有两种，在线安装和本地安装。本文档采用本地安装方式进行head插件的安装。elasticsearch-5-*以上版本安装head需要安装node和grunt</p><p>1）下载head插件：<a href="https://github.com/mobz/elasticsearch-head">https://github.com/mobz/elasticsearch-head</a>  </p><p>在资料中已经提供了elasticsearch-head-master插件压缩包：</p><p><img src="image%5C3.png"></p><p>2）将elasticsearch-head-master压缩包解压到任意目录，但是要和elasticsearch的安装目录区别开</p><p>3）下载nodejs：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a> </p><p>在资料中已经提供了nodejs安装程序：</p><p><img src="image%5C14.png"></p><p>双击安装程序，步骤截图如下：</p><p><img src="image%5C15.png"></p><p><img src="image%5C16.png"></p><p><img src="image%5C17.png"></p><p><img src="image%5C18.png"></p><p><img src="image%5C20.png"></p><p>安装完毕，可以通过cmd控制台输入：node -v 查看版本号</p><p>5）将grunt安装为全局命令 ，Grunt是基于Node.js的项目构建工具</p><p>在cmd控制台中输入如下执行命令：</p><pre><code>npm install -g grunt-cli</code></pre><p>执行结果如下图：</p><p><img src="image%5C21.png"></p><p>6）进入elasticsearch-head-master目录启动head，在命令提示符下输入命令：</p><pre><code>&gt;npm install&gt;grunt server</code></pre><p><img src="image%5C23.png"></p><p>7）打开浏览器，输入 <a href="http://localhost:9100，看到如下页面：">http://localhost:9100，看到如下页面：</a></p><p><img src="image%5C24.png"></p><p>如果不能成功连接到es服务，需要修改ElasticSearch的config目录下的配置文件：config/elasticsearch.yml，增加以下两句命令：</p><pre><code>http.cors.enabled: truehttp.cors.allow-origin: "*"</code></pre><p>然后重新启动ElasticSearch服务。</p><h1 id="第三章-ElasticSearch相关概念-术语"><a href="#第三章-ElasticSearch相关概念-术语" class="headerlink" title="第三章 ElasticSearch相关概念(术语)"></a>第三章 ElasticSearch相关概念(术语)</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>Elasticsearch是面向文档(document oriented)的，这意味着它可以存储整个对象或文档(document)。然而它不仅仅是存储，还会索引(index)每个文档的内容使之可以被搜索。在Elasticsearch中，你可以对文档（而非成行成列的数据）进行索引、搜索、排序、过滤。Elasticsearch比传统关系型数据库如下：</p><pre><code>Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; ColumnsElasticsearch -&gt; Indices   -&gt; Types  -&gt; Documents -&gt; Fields</code></pre><h2 id="3-2-Elasticsearch核心概念"><a href="#3-2-Elasticsearch核心概念" class="headerlink" title="3.2 Elasticsearch核心概念"></a>3.2 <strong>Elasticsearch核心概念</strong></h2><h3 id="3-2-1-索引-index"><a href="#3-2-1-索引-index" class="headerlink" title="3.2.1 索引 index"></a>3.2.1 索引 index</h3><p>一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。</p><h3 id="3-2-2-类型-type"><a href="#3-2-2-类型-type" class="headerlink" title="3.2.2 类型 type"></a>3.2.2 类型 type</h3><p>在一个索引中，你可以定义一种或多种类型。一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。比如说，我们假设你运营一个博客平台并且将你所有的数据存储到一个索引中。在这个索引中，你可以为用户数据定义一个类型，为博客数据定义另一个类型，当然，也可以为评论数据定义另一个类型。</p><h3 id="3-2-3-字段Field"><a href="#3-2-3-字段Field" class="headerlink" title="3.2.3 字段Field"></a>3.2.3 字段Field</h3><p>相当于是数据表的字段，对文档数据根据不同属性进行的分类标识</p><h3 id="3-2-4-映射-mapping"><a href="#3-2-4-映射-mapping" class="headerlink" title="3.2.4 映射 mapping"></a>3.2.4 映射 mapping</h3><p>mapping是处理数据的方式和规则方面做一些限制，如某个字段的数据类型、默认值、分析器、是否被索引等等，这些都是映射里面可以设置的，其它就是处理es里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。</p><h3 id="3-2-5-文档-document"><a href="#3-2-5-文档-document" class="headerlink" title="3.2.5 文档 document"></a>3.2.5 文档 document</h3><p>一个文档是一个可被索引的基础信息单元。比如，你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以JSON（Javascript Object Notation）格式来表示，而JSON是一个到处存在的互联网数据交互格式。</p><p>在一个index/type里面，你可以存储任意多的文档。注意，尽管一个文档，物理上存在于一个索引之中，文档必须被索引/赋予一个索引的type。</p><h3 id="3-2-6-接近实时-NRT"><a href="#3-2-6-接近实时-NRT" class="headerlink" title="3.2.6 接近实时 NRT"></a>3.2.6 接近实时 NRT</h3><p>Elasticsearch是一个接近实时的搜索平台。这意味着，从索引一个文档直到这个文档能够被搜索到有一个轻微的延迟（通常是1秒以内）</p><h3 id="3-2-7-集群-cluster"><a href="#3-2-7-集群-cluster" class="headerlink" title="3.2.7 集群 cluster"></a>3.2.7 集群 cluster</h3><p>一个集群就是由一个或多个节点组织在一起，它们共同持有整个的数据，并一起提供索引和搜索功能。一个集群由一个唯一的名字标识，这个名字默认就是“elasticsearch”。这个名字是重要的，因为一个节点只能通过指定某个集群的名字，来加入这个集群</p><h3 id="3-2-8-节点-node"><a href="#3-2-8-节点-node" class="headerlink" title="3.2.8 节点 node"></a>3.2.8 节点 node</h3><p>一个节点是集群中的一个服务器，作为集群的一部分，它存储数据，参与集群的索引和搜索功能。和集群类似，一个节点也是由一个名字来标识的，默认情况下，这个名字是一个随机的漫威漫画角色的名字，这个名字会在启动的时候赋予节点。这个名字对于管理工作来说挺重要的，因为在这个管理过程中，你会去确定网络中的哪些服务器对应于Elasticsearch集群中的哪些节点。</p><p>一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做“elasticsearch”的集群中，这意味着，如果你在你的网络中启动了若干个节点，并假定它们能够相互发现彼此，它们将会自动地形成并加入到一个叫做“elasticsearch”的集群中。</p><p>在一个集群里，只要你想，可以拥有任意多个节点。而且，如果当前你的网络中没有运行任何Elasticsearch节点，这时启动一个节点，会默认创建并加入一个叫做“elasticsearch”的集群。</p><h3 id="3-2-9-分片和复制-shards-amp-replicas"><a href="#3-2-9-分片和复制-shards-amp-replicas" class="headerlink" title="3.2.9 分片和复制 shards&amp;replicas"></a>3.2.9 分片和复制 shards&amp;replicas</h3><p>一个索引可以存储超出单个结点硬件限制的大量数据。比如，一个具有10亿文档的索引占据1TB的磁盘空间，而任一节点都没有这样大的磁盘空间；或者单个节点处理搜索请求，响应太慢。为了解决这个问题，Elasticsearch提供了将索引划分成多份的能力，这些份就叫做分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。分片很重要，主要有两方面的原因：<br>1）允许你水平分割/扩展你的内容容量。<br>2）允许你在分片（潜在地，位于多个节点上）之上进行分布式的、并行的操作，进而提高性能/吞吐量。</p><p>至于一个分片怎样分布，它的文档怎样聚合回搜索请求，是完全由Elasticsearch管理的，对于作为用户的你来说，这些都是透明的。</p><p>在一个网络/云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elasticsearch允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片，或者直接叫复制。</p><p>复制之所以重要，有两个主要原因： 在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。扩展你的搜索量/吞吐量，因为搜索可以在所有的复制上并行运行。总之，每个索引可以被分成多个分片。一个索引也可以被复制0次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制的数量，但是你事后不能改变分片的数量。</p><p>默认情况下，Elasticsearch中的每个索引被分片5个主分片和1个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有5个主分片和另外5个复制分片（1个完全拷贝），这样的话每个索引总共就有10个分片。</p><h1 id="第四章-ElasticSearch的客户端操作"><a href="#第四章-ElasticSearch的客户端操作" class="headerlink" title="第四章 ElasticSearch的客户端操作"></a>第四章 ElasticSearch的客户端操作</h1><p>实际开发中，主要有三种方式可以作为elasticsearch服务的客户端：</p><ul><li>第一种，elasticsearch-head插件</li><li>第二种，使用elasticsearch提供的Restful接口直接访问</li><li>第三种，使用elasticsearch提供的API进行访问</li></ul><h2 id="4-1-安装Postman工具"><a href="#4-1-安装Postman工具" class="headerlink" title="4.1 安装Postman工具"></a>4.1 安装Postman工具</h2><p>Postman中文版是postman这款强大网页调试工具的windows客户端，提供功能强大的Web API &amp; HTTP 请求调试。软件功能非常强大，界面简洁明晰、操作方便快捷，设计得很人性化。Postman中文版能够发送任何类型的HTTP 请求 (GET, HEAD, POST, PUT..)，且可以附带任何数量的参数。</p><h2 id="4-1-下载Postman工具"><a href="#4-1-下载Postman工具" class="headerlink" title="4.1 下载Postman工具"></a>4.1 下载Postman工具</h2><p>Postman官网：<a href="https://www.getpostman.com/">https://www.getpostman.com</a></p><p>课程资料中已经提供了安装包</p><p><img src="image%5C41.png"></p><h2 id="4-2-注册Postman工具"><a href="#4-2-注册Postman工具" class="headerlink" title="4.2 注册Postman工具"></a>4.2 注册Postman工具</h2><p><img src="image%5C42.png"></p><p><img src="image%5C43.png"></p><h2 id="4-2-使用Postman工具进行Restful接口访问"><a href="#4-2-使用Postman工具进行Restful接口访问" class="headerlink" title="4.2 使用Postman工具进行Restful接口访问"></a>4.2 使用Postman工具进行Restful接口访问</h2><h3 id="4-2-1-ElasticSearch的接口语法"><a href="#4-2-1-ElasticSearch的接口语法" class="headerlink" title="4.2.1 ElasticSearch的接口语法"></a>4.2.1 ElasticSearch的接口语法</h3><pre><code>curl -X&lt;VERB&gt; '&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;' -d '&lt;BODY&gt;'</code></pre><p>其中：</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td><code>VERB</code></td><td>适当的 HTTP <em>方法</em> 或 <em>谓词</em> : <code>GET</code>、 <code>POST</code>、 <code>PUT</code>、 <code>HEAD</code> 或者 <code>DELETE</code>。</td></tr><tr><td><code>PROTOCOL</code></td><td><code>http</code> 或者 <code>https</code>（如果你在 Elasticsearch 前面有一个 <code>https</code> 代理）</td></tr><tr><td><code>HOST</code></td><td>Elasticsearch 集群中任意节点的主机名，或者用 <code>localhost</code> 代表本地机器上的节点。</td></tr><tr><td><code>PORT</code></td><td>运行 Elasticsearch HTTP 服务的端口号，默认是 <code>9200</code> 。</td></tr><tr><td><code>PATH</code></td><td>API 的终端路径（例如 <code>_count</code> 将返回集群中文档数量）。Path 可能包含多个组件，例如：<code>_cluster/stats</code> 和 <code>_nodes/stats/jvm</code> 。</td></tr><tr><td><code>QUERY_STRING</code></td><td>任意可选的查询字符串参数 (例如 <code>?pretty</code> 将格式化地输出 JSON 返回值，使其更容易阅读)</td></tr><tr><td><code>BODY</code></td><td>一个 JSON 格式的请求体 (如果请求需要的话)</td></tr></tbody></table><h3 id="4-2-2-创建索引index和映射mapping"><a href="#4-2-2-创建索引index和映射mapping" class="headerlink" title="4.2.2 创建索引index和映射mapping"></a>4.2.2 创建索引index和映射mapping</h3><p>请求url：</p><pre class=" language-json"><code class="language-json">PUT        localhost<span class="token operator">:</span><span class="token number">9200</span>/blog1</code></pre><p>请求体：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"mappings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"article"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token property">"id"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"long"</span><span class="token punctuation">,</span>                    <span class="token property">"store"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                    <span class="token property">"index"</span><span class="token operator">:</span><span class="token string">"not_analyzed"</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token property">"title"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>                    <span class="token property">"store"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                    <span class="token property">"index"</span><span class="token operator">:</span><span class="token string">"analyzed"</span><span class="token punctuation">,</span>                    <span class="token property">"analyzer"</span><span class="token operator">:</span><span class="token string">"standard"</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token property">"content"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>                    <span class="token property">"store"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                    <span class="token property">"index"</span><span class="token operator">:</span><span class="token string">"analyzed"</span><span class="token punctuation">,</span>                    <span class="token property">"analyzer"</span><span class="token operator">:</span><span class="token string">"standard"</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>postman截图：</p><p><img src="image%5C46.png"></p><p>elasticsearch-head查看：</p><p><img src="image%5C47.png"></p><p>###4.2.3 创建索引后设置Mapping</p><p>我们可以在创建索引时设置mapping信息，当然也可以先创建索引然后再设置mapping。</p><p>在上一个步骤中不设置maping信息，直接使用put方法创建一个索引，然后设置mapping信息。</p><p>请求的url：</p><pre><code>POST    http://127.0.0.1:9200/blog2/hello/_mapping</code></pre><p>请求体：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"hello"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token property">"id"</span><span class="token operator">:</span><span class="token punctuation">{</span>                    <span class="token property">"type"</span><span class="token operator">:</span><span class="token string">"long"</span><span class="token punctuation">,</span>                    <span class="token property">"store"</span><span class="token operator">:</span><span class="token boolean">true</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token property">"title"</span><span class="token operator">:</span><span class="token punctuation">{</span>                    <span class="token property">"type"</span><span class="token operator">:</span><span class="token string">"text"</span><span class="token punctuation">,</span>                    <span class="token property">"store"</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>                    <span class="token property">"index"</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>                    <span class="token property">"analyzer"</span><span class="token operator">:</span><span class="token string">"standard"</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token property">"content"</span><span class="token operator">:</span><span class="token punctuation">{</span>                    <span class="token property">"type"</span><span class="token operator">:</span><span class="token string">"text"</span><span class="token punctuation">,</span>                    <span class="token property">"store"</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>                    <span class="token property">"index"</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>                    <span class="token property">"analyzer"</span><span class="token operator">:</span><span class="token string">"standard"</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>PostMan截图<br><img src="image%5C61.png"></p><h3 id="4-2-4-删除索引index"><a href="#4-2-4-删除索引index" class="headerlink" title="4.2.4 删除索引index"></a>4.2.4 删除索引index</h3><p>请求url：</p><pre class=" language-json"><code class="language-json">DELETE        localhost<span class="token operator">:</span><span class="token number">9200</span>/blog1</code></pre><p>postman截图：</p><p><img src="image%5C48.png"></p><p>elasticsearch-head查看：</p><p><img src="image%5C49.png"></p><h3 id="4-2-5-创建文档document"><a href="#4-2-5-创建文档document" class="headerlink" title="4.2.5 创建文档document"></a>4.2.5 创建文档document</h3><p>请求url：</p><pre class=" language-json"><code class="language-json">POST    localhost<span class="token operator">:</span><span class="token number">9200</span>/blog1/article/<span class="token number">1</span></code></pre><p>请求体：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"id"</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span><span class="token string">"ElasticSearch是一个基于Lucene的搜索服务器"</span><span class="token punctuation">,</span>    <span class="token property">"content"</span><span class="token operator">:</span><span class="token string">"它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。"</span><span class="token punctuation">}</span></code></pre><p>postman截图：</p><p><img src="image%5C50.png"></p><p>elasticsearch-head查看：</p><p><img src="image%5C51.png"></p><h3 id="4-2-6-修改文档document"><a href="#4-2-6-修改文档document" class="headerlink" title="4.2.6 修改文档document"></a>4.2.6 修改文档document</h3><p>请求url：</p><pre class=" language-json"><code class="language-json">POST    localhost<span class="token operator">:</span><span class="token number">9200</span>/blog1/article/<span class="token number">1</span></code></pre><p>请求体：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"id"</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span><span class="token string">"【修改】ElasticSearch是一个基于Lucene的搜索服务器"</span><span class="token punctuation">,</span>    <span class="token property">"content"</span><span class="token operator">:</span><span class="token string">"【修改】它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。"</span><span class="token punctuation">}</span></code></pre><p>postman截图：</p><p><img src="image%5C52.png"></p><p>elasticsearch-head查看：</p><p><img src="image%5C53.png"></p><h3 id="4-2-7-删除文档document"><a href="#4-2-7-删除文档document" class="headerlink" title="4.2.7 删除文档document"></a>4.2.7 删除文档document</h3><p>请求url：</p><pre class=" language-json"><code class="language-json">DELETE    localhost<span class="token operator">:</span><span class="token number">9200</span>/blog1/article/<span class="token number">1</span></code></pre><p>postman截图：</p><p><img src="image%5C54.png"></p><p>elasticsearch-head查看：</p><p><img src="image%5C55.png"></p><h3 id="4-2-8-查询文档-根据id查询"><a href="#4-2-8-查询文档-根据id查询" class="headerlink" title="4.2.8 查询文档-根据id查询"></a>4.2.8 查询文档-根据id查询</h3><p>请求url：</p><pre class=" language-json"><code class="language-json">GET    localhost<span class="token operator">:</span><span class="token number">9200</span>/blog1/article/<span class="token number">1</span></code></pre><p>postman截图：</p><p><img src="image%5C56.png"></p><h3 id="4-2-9-查询文档-querystring查询"><a href="#4-2-9-查询文档-querystring查询" class="headerlink" title="4.2.9 查询文档-querystring查询"></a>4.2.9 查询文档-querystring查询</h3><p>请求url：</p><pre class=" language-json"><code class="language-json">POST    localhost<span class="token operator">:</span><span class="token number">9200</span>/blog1/article/_search</code></pre><p>请求体：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"query_string"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"default_field"</span><span class="token operator">:</span> <span class="token string">"title"</span><span class="token punctuation">,</span>            <span class="token property">"query"</span><span class="token operator">:</span> <span class="token string">"搜索服务器"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>postman截图：</p><p><img src="image%5C57.png"></p><p>注意：</p><p>将搜索内容”搜索服务器”修改为”钢索”，同样也能搜索到文档，该原因会在下面讲解中得到答案</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"query_string"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"default_field"</span><span class="token operator">:</span> <span class="token string">"title"</span><span class="token punctuation">,</span>            <span class="token property">"query"</span><span class="token operator">:</span> <span class="token string">"钢索"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="4-2-10-查询文档-term查询"><a href="#4-2-10-查询文档-term查询" class="headerlink" title="4.2.10 查询文档-term查询"></a>4.2.10 查询文档-term查询</h3><p>请求url：</p><pre class=" language-json"><code class="language-json">POST    localhost<span class="token operator">:</span><span class="token number">9200</span>/blog1/article/_search</code></pre><p>请求体：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"term"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"搜索"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>postman截图：</p><p><img src="image%5C58.png"></p><h1 id="第五章-IK-分词器和ElasticSearch集成使用"><a href="#第五章-IK-分词器和ElasticSearch集成使用" class="headerlink" title="第五章 IK 分词器和ElasticSearch集成使用"></a>第五章 IK 分词器和ElasticSearch集成使用</h1><h2 id="5-1-上述查询存在问题分析"><a href="#5-1-上述查询存在问题分析" class="headerlink" title="5.1 上述查询存在问题分析"></a>5.1 上述查询存在问题分析</h2><p>在进行字符串查询时，我们发现去搜索”搜索服务器”和”钢索”都可以搜索到数据；</p><p>而在进行词条查询时，我们搜索”搜索”却没有搜索到数据；</p><p>究其原因是ElasticSearch的标准分词器导致的，当我们创建索引时，字段使用的是标准分词器：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"mappings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"article"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token property">"id"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"long"</span><span class="token punctuation">,</span>                    <span class="token property">"store"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                    <span class="token property">"index"</span><span class="token operator">:</span><span class="token string">"not_analyzed"</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token property">"title"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>                    <span class="token property">"store"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                    <span class="token property">"index"</span><span class="token operator">:</span><span class="token string">"analyzed"</span><span class="token punctuation">,</span>                    <span class="token property">"analyzer"</span><span class="token operator">:</span><span class="token string">"standard"</span>    //标准分词器                <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token property">"content"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>                    <span class="token property">"store"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                    <span class="token property">"index"</span><span class="token operator">:</span><span class="token string">"analyzed"</span><span class="token punctuation">,</span>                    <span class="token property">"analyzer"</span><span class="token operator">:</span><span class="token string">"standard"</span>    //标准分词器                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>例如对 “我是程序员” 进行分词</p><p>标准分词器分词效果测试：</p><pre class=" language-http"><code class="language-http"><span class="token header-name keyword">http:</span>//127.0.0.1:9200/_analyze?analyzer=standard&amp;pretty=true&amp;text=我是程序员</code></pre><p>分词结果：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"tokens"</span> <span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token property">"token"</span> <span class="token operator">:</span> <span class="token string">"我"</span><span class="token punctuation">,</span>      <span class="token property">"start_offset"</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>      <span class="token property">"end_offset"</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>      <span class="token property">"type"</span> <span class="token operator">:</span> <span class="token string">"&lt;IDEOGRAPHIC>"</span><span class="token punctuation">,</span>      <span class="token property">"position"</span> <span class="token operator">:</span> <span class="token number">0</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      <span class="token property">"token"</span> <span class="token operator">:</span> <span class="token string">"是"</span><span class="token punctuation">,</span>      <span class="token property">"start_offset"</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>      <span class="token property">"end_offset"</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>      <span class="token property">"type"</span> <span class="token operator">:</span> <span class="token string">"&lt;IDEOGRAPHIC>"</span><span class="token punctuation">,</span>      <span class="token property">"position"</span> <span class="token operator">:</span> <span class="token number">1</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      <span class="token property">"token"</span> <span class="token operator">:</span> <span class="token string">"程"</span><span class="token punctuation">,</span>      <span class="token property">"start_offset"</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>      <span class="token property">"end_offset"</span> <span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>      <span class="token property">"type"</span> <span class="token operator">:</span> <span class="token string">"&lt;IDEOGRAPHIC>"</span><span class="token punctuation">,</span>      <span class="token property">"position"</span> <span class="token operator">:</span> <span class="token number">2</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      <span class="token property">"token"</span> <span class="token operator">:</span> <span class="token string">"序"</span><span class="token punctuation">,</span>      <span class="token property">"start_offset"</span> <span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>      <span class="token property">"end_offset"</span> <span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>      <span class="token property">"type"</span> <span class="token operator">:</span> <span class="token string">"&lt;IDEOGRAPHIC>"</span><span class="token punctuation">,</span>      <span class="token property">"position"</span> <span class="token operator">:</span> <span class="token number">3</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      <span class="token property">"token"</span> <span class="token operator">:</span> <span class="token string">"员"</span><span class="token punctuation">,</span>      <span class="token property">"start_offset"</span> <span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>      <span class="token property">"end_offset"</span> <span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>      <span class="token property">"type"</span> <span class="token operator">:</span> <span class="token string">"&lt;IDEOGRAPHIC>"</span><span class="token punctuation">,</span>      <span class="token property">"position"</span> <span class="token operator">:</span> <span class="token number">4</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>而我们需要的分词效果是：我、是、程序、程序员</p><p>这样的话就需要对中文支持良好的分析器的支持，支持中文分词的分词器有很多，word分词器、庖丁解牛、盘古分词、Ansj分词等，但我们常用的还是下面要介绍的IK分词器。</p><h2 id="5-2-IK分词器简介"><a href="#5-2-IK分词器简介" class="headerlink" title="5.2 IK分词器简介"></a>5.2 IK分词器简介</h2><p>IKAnalyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包。从2006年12月推出1.0版开始，IKAnalyzer已经推出 了3个大版本。最初，它是以开源项目Lucene为应用主体的，结合词典分词和文法分析算法的中文分词组件。新版本的IKAnalyzer3.0则发展为 面向Java的公用分词组件，独立于Lucene项目，同时提供了对Lucene的默认优化实现。</p><p>IK分词器3.0的特性如下：</p><p>1）采用了特有的“正向迭代最细粒度切分算法“，具有60万字/秒的高速处理能力。<br>2）采用了多子处理器分析模式，支持：英文字母（IP地址、Email、URL）、数字（日期，常用中文数量词，罗马数字，科学计数法），中文词汇（姓名、地名处理）等分词处理。<br>3）对中英联合支持不是很好,在这方面的处理比较麻烦.需再做一次查询,同时是支持个人词条的优化的词典存储，更小的内存占用。<br>4）支持用户词典扩展定义。<br>5）针对Lucene全文检索优化的查询分析器IKQueryParser；采用歧义分析算法优化查询关键字的搜索排列组合，能极大的提高Lucene检索的命中率。</p><h2 id="5-3-ElasticSearch集成IK分词器"><a href="#5-3-ElasticSearch集成IK分词器" class="headerlink" title="5.3 ElasticSearch集成IK分词器"></a>5.3 ElasticSearch集成IK分词器</h2><h3 id="5-3-1-IK分词器的安装"><a href="#5-3-1-IK分词器的安装" class="headerlink" title="5.3.1 IK分词器的安装"></a>5.3.1 IK分词器的安装</h3><p>1）下载地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a>&nbsp;  </p><p>课程资料也提供了IK分词器的压缩包：</p><p><img src="image/34.png"></p><p>2）解压，将解压后的elasticsearch文件夹拷贝到elasticsearch-5.6.8\plugins下，并重命名文件夹为analysis-ik</p><p><img src="image/35.png"></p><p>3）重新启动ElasticSearch，即可加载IK分词器</p><p><img src="image/36.png"></p><h3 id="5-3-2-IK分词器测试"><a href="#5-3-2-IK分词器测试" class="headerlink" title="5.3.2 IK分词器测试"></a>5.3.2 IK分词器测试</h3><p>IK提供了两个分词算法ik_smart 和 ik_max_word</p><p>其中 ik_smart 为最少切分，ik_max_word为最细粒度划分</p><p>我们分别来试一下</p><p>1）最小切分：在浏览器地址栏输入地址</p><pre class=" language-http"><code class="language-http"><span class="token header-name keyword">http:</span>//127.0.0.1:9200/_analyze?analyzer=ik_smart&amp;pretty=true&amp;text=我是程序员</code></pre><p>输出的结果为：</p><pre><code>{  "tokens" : [    {      "token" : "我",      "start_offset" : 0,      "end_offset" : 1,      "type" : "CN_CHAR",      "position" : 0    },    {      "token" : "是",      "start_offset" : 1,      "end_offset" : 2,      "type" : "CN_CHAR",      "position" : 1    },    {      "token" : "程序员",      "start_offset" : 2,      "end_offset" : 5,      "type" : "CN_WORD",      "position" : 2    }  ]}</code></pre><p>2）最细切分：在浏览器地址栏输入地址</p><pre class=" language-http"><code class="language-http"><span class="token header-name keyword">http:</span>//127.0.0.1:9200/_analyze?analyzer=ik_max_word&amp;pretty=true&amp;text=我是程序员</code></pre><p>输出的结果为：</p><pre><code>{  "tokens" : [    {      "token" : "我",      "start_offset" : 0,      "end_offset" : 1,      "type" : "CN_CHAR",      "position" : 0    },    {      "token" : "是",      "start_offset" : 1,      "end_offset" : 2,      "type" : "CN_CHAR",      "position" : 1    },    {      "token" : "程序员",      "start_offset" : 2,      "end_offset" : 5,      "type" : "CN_WORD",      "position" : 2    },    {      "token" : "程序",      "start_offset" : 2,      "end_offset" : 4,      "type" : "CN_WORD",      "position" : 3    },    {      "token" : "员",      "start_offset" : 4,      "end_offset" : 5,      "type" : "CN_CHAR",      "position" : 4    }  ]}</code></pre><h2 id="5-4-修改索引映射mapping"><a href="#5-4-修改索引映射mapping" class="headerlink" title="5.4 修改索引映射mapping"></a>5.4 修改索引映射mapping</h2><h3 id="5-4-1-重建索引"><a href="#5-4-1-重建索引" class="headerlink" title="5.4.1 重建索引"></a>5.4.1 重建索引</h3><p>删除原有blog1索引</p><pre class=" language-json"><code class="language-json">DELETE        localhost<span class="token operator">:</span><span class="token number">9200</span>/blog1</code></pre><p>创建blog1索引，此时分词器使用ik_max_word</p><pre class=" language-json"><code class="language-json">PUT        localhost<span class="token operator">:</span><span class="token number">9200</span>/blog1</code></pre><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"mappings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"article"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token property">"id"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"long"</span><span class="token punctuation">,</span>                    <span class="token property">"store"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                    <span class="token property">"index"</span><span class="token operator">:</span><span class="token string">"not_analyzed"</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token property">"title"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>                    <span class="token property">"store"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                    <span class="token property">"index"</span><span class="token operator">:</span><span class="token string">"analyzed"</span><span class="token punctuation">,</span>                    <span class="token property">"analyzer"</span><span class="token operator">:</span><span class="token string">"ik_max_word"</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token property">"content"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>                    <span class="token property">"store"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                    <span class="token property">"index"</span><span class="token operator">:</span><span class="token string">"analyzed"</span><span class="token punctuation">,</span>                    <span class="token property">"analyzer"</span><span class="token operator">:</span><span class="token string">"ik_max_word"</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>创建文档</p><pre class=" language-json"><code class="language-json">POST    localhost<span class="token operator">:</span><span class="token number">9200</span>/blog1/article/<span class="token number">1</span></code></pre><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"id"</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span><span class="token string">"ElasticSearch是一个基于Lucene的搜索服务器"</span><span class="token punctuation">,</span>    <span class="token property">"content"</span><span class="token operator">:</span><span class="token string">"它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。"</span><span class="token punctuation">}</span></code></pre><h3 id="5-4-2-再次测试queryString查询"><a href="#5-4-2-再次测试queryString查询" class="headerlink" title="5.4.2 再次测试queryString查询"></a>5.4.2 再次测试queryString查询</h3><p>请求url：</p><pre class=" language-json"><code class="language-json">POST    localhost<span class="token operator">:</span><span class="token number">9200</span>/blog1/article/_search</code></pre><p>请求体：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"query_string"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"default_field"</span><span class="token operator">:</span> <span class="token string">"title"</span><span class="token punctuation">,</span>            <span class="token property">"query"</span><span class="token operator">:</span> <span class="token string">"搜索服务器"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>postman截图：</p><p><img src="image/57.png"></p><p>将请求体搜索字符串修改为”钢索”，再次查询：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"query_string"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"default_field"</span><span class="token operator">:</span> <span class="token string">"title"</span><span class="token punctuation">,</span>            <span class="token property">"query"</span><span class="token operator">:</span> <span class="token string">"钢索"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>postman截图：</p><p><img src="image%5C59.png"></p><h3 id="5-4-3-再次测试term测试"><a href="#5-4-3-再次测试term测试" class="headerlink" title="5.4.3 再次测试term测试"></a>5.4.3 再次测试term测试</h3><p>请求url：</p><pre class=" language-json"><code class="language-json">POST    localhost<span class="token operator">:</span><span class="token number">9200</span>/blog1/article/_search</code></pre><p>请求体：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"term"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"搜索"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>postman截图：</p><p><img src="image%5C60.png"></p><h1 id="第六章-ElasticSearch集群"><a href="#第六章-ElasticSearch集群" class="headerlink" title="第六章 ElasticSearch集群"></a>第六章 ElasticSearch集群</h1><p>​    ES集群是一个 P2P类型(使用 gossip 协议)的分布式系统，除了集群状态管理以外，其他所有的请求都可以发送到集群内任意一台节点上，这个节点可以自己找到需要转发给哪些节点，并且直接跟这些节点通信。所以，从网络架构及服务配置上来说，构建集群所需要的配置极其简单。在 Elasticsearch 2.0 之前，无阻碍的网络下，所有配置了相同 cluster.name 的节点都自动归属到一个集群中。2.0 版本之后，基于安全的考虑避免开发环境过于随便造成的麻烦，从 2.0 版本开始，默认的自动发现方式改为了单播(unicast)方式。配置里提供几台节点的地址，ES 将其视作 gossip router 角色，借以完成集群的发现。由于这只是 ES 内一个很小的功能，所以 gossip router 角色并不需要单独配置，每个 ES 节点都可以担任。所以，采用单播方式的集群，各节点都配置相同的几个节点列表作为 router 即可。</p><p>​    集群中节点数量没有限制，一般大于等于2个节点就可以看做是集群了。一般处于高性能及高可用方面来考虑一般集群中的节点数量都是3个及3个以上。</p><h2 id="6-1-集群的相关概念"><a href="#6-1-集群的相关概念" class="headerlink" title="6.1 集群的相关概念"></a>6.1 集群的相关概念</h2><h3 id="6-1-1-集群-cluster"><a href="#6-1-1-集群-cluster" class="headerlink" title="6.1.1 集群 cluster"></a>6.1.1 集群 cluster</h3><p>一个集群就是由一个或多个节点组织在一起，它们共同持有整个的数据，并一起提供索引和搜索功能。一个集群由一个唯一的名字标识，这个名字默认就是“elasticsearch”。这个名字是重要的，因为一个节点只能通过指定某个集群的名字，来加入这个集群</p><h3 id="6-1-2-节点-node"><a href="#6-1-2-节点-node" class="headerlink" title="6.1.2 节点 node"></a>6.1.2 节点 node</h3><p>一个节点是集群中的一个服务器，作为集群的一部分，它存储数据，参与集群的索引和搜索功能。和集群类似，一个节点也是由一个名字来标识的，默认情况下，这个名字是一个随机的漫威漫画角色的名字，这个名字会在启动的时候赋予节点。这个名字对于管理工作来说挺重要的，因为在这个管理过程中，你会去确定网络中的哪些服务器对应于Elasticsearch集群中的哪些节点。</p><p>一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做“elasticsearch”的集群中，这意味着，如果你在你的网络中启动了若干个节点，并假定它们能够相互发现彼此，它们将会自动地形成并加入到一个叫做“elasticsearch”的集群中。</p><p>在一个集群里，只要你想，可以拥有任意多个节点。而且，如果当前你的网络中没有运行任何Elasticsearch节点，这时启动一个节点，会默认创建并加入一个叫做“elasticsearch”的集群。</p><h3 id="6-1-3-分片和复制-shards-amp-replicas"><a href="#6-1-3-分片和复制-shards-amp-replicas" class="headerlink" title="6.1.3 分片和复制 shards&amp;replicas"></a>6.1.3 分片和复制 shards&amp;replicas</h3><p>一个索引可以存储超出单个结点硬件限制的大量数据。比如，一个具有10亿文档的索引占据1TB的磁盘空间，而任一节点都没有这样大的磁盘空间；或者单个节点处理搜索请求，响应太慢。为了解决这个问题，Elasticsearch提供了将索引划分成多份的能力，这些份就叫做分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。分片很重要，主要有两方面的原因：<br>1）允许你水平分割/扩展你的内容容量。<br>2）允许你在分片（潜在地，位于多个节点上）之上进行分布式的、并行的操作，进而提高性能/吞吐量。</p><p>至于一个分片怎样分布，它的文档怎样聚合回搜索请求，是完全由Elasticsearch管理的，对于作为用户的你来说，这些都是透明的。</p><p>在一个网络/云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elasticsearch允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片，或者直接叫复制。</p><p>复制之所以重要，有两个主要原因： 在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。扩展你的搜索量/吞吐量，因为搜索可以在所有的复制上并行运行。总之，每个索引可以被分成多个分片。一个索引也可以被复制0次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制的数量，但是你事后不能改变分片的数量。</p><p>默认情况下，Elasticsearch中的每个索引被分片5个主分片和1个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有5个主分片和另外5个复制分片（1个完全拷贝），这样的话每个索引总共就有10个分片。</p><h2 id="6-2-集群的搭建"><a href="#6-2-集群的搭建" class="headerlink" title="6.2 集群的搭建"></a>6.2 集群的搭建</h2><h3 id="6-2-1-准备三台elasticsearch服务器"><a href="#6-2-1-准备三台elasticsearch服务器" class="headerlink" title="6.2.1 准备三台elasticsearch服务器"></a>6.2.1 准备三台elasticsearch服务器</h3><p>创建elasticsearch-cluster文件夹，在内部复制三个elasticsearch服务</p><h3 id="6-2-2-修改每台服务器配置"><a href="#6-2-2-修改每台服务器配置" class="headerlink" title="6.2.2 修改每台服务器配置"></a>6.2.2 修改每台服务器配置</h3><p>修改elasticsearch-cluster\node*\config\elasticsearch.yml配置文件</p><h4 id="node1节点："><a href="#node1节点：" class="headerlink" title="node1节点："></a>node1节点：</h4><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true">#节点1的配置信息：</span><span class="token comment" spellcheck="true">#集群名称，保证唯一</span><span class="token key atrule">cluster.name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>elasticsearch<span class="token comment" spellcheck="true">#节点名称，必须不一样</span><span class="token key atrule">node.name</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span><span class="token number">1</span><span class="token comment" spellcheck="true">#必须为本机的ip地址</span><span class="token key atrule">network.host</span><span class="token punctuation">:</span> 127.0.0.1<span class="token comment" spellcheck="true">#服务端口号，在同一机器下必须不一样</span><span class="token key atrule">http.port</span><span class="token punctuation">:</span> <span class="token number">9200</span><span class="token comment" spellcheck="true">#集群间通信端口号，在同一机器下必须不一样</span><span class="token key atrule">transport.tcp.port</span><span class="token punctuation">:</span> <span class="token number">9300</span><span class="token comment" spellcheck="true">#设置集群自动发现机器ip集合</span><span class="token key atrule">discovery.zen.ping.unicast.hosts</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"127.0.0.1:9300"</span><span class="token punctuation">,</span><span class="token string">"127.0.0.1:9301"</span><span class="token punctuation">,</span><span class="token string">"127.0.0.1:9302"</span><span class="token punctuation">]</span></code></pre><h4 id="node2节点："><a href="#node2节点：" class="headerlink" title="node2节点："></a>node2节点：</h4><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true">#节点2的配置信息：</span><span class="token comment" spellcheck="true">#集群名称，保证唯一</span><span class="token key atrule">cluster.name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>elasticsearch<span class="token comment" spellcheck="true">#节点名称，必须不一样</span><span class="token key atrule">node.name</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span><span class="token number">2</span><span class="token comment" spellcheck="true">#必须为本机的ip地址</span><span class="token key atrule">network.host</span><span class="token punctuation">:</span> 127.0.0.1<span class="token comment" spellcheck="true">#服务端口号，在同一机器下必须不一样</span><span class="token key atrule">http.port</span><span class="token punctuation">:</span> <span class="token number">9201</span><span class="token comment" spellcheck="true">#集群间通信端口号，在同一机器下必须不一样</span><span class="token key atrule">transport.tcp.port</span><span class="token punctuation">:</span> <span class="token number">9301</span><span class="token comment" spellcheck="true">#设置集群自动发现机器ip集合</span><span class="token key atrule">discovery.zen.ping.unicast.hosts</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"127.0.0.1:9300"</span><span class="token punctuation">,</span><span class="token string">"127.0.0.1:9301"</span><span class="token punctuation">,</span><span class="token string">"127.0.0.1:9302"</span><span class="token punctuation">]</span></code></pre><h4 id="node3节点："><a href="#node3节点：" class="headerlink" title="node3节点："></a>node3节点：</h4><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true">#节点3的配置信息：</span><span class="token comment" spellcheck="true">#集群名称，保证唯一</span><span class="token key atrule">cluster.name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>elasticsearch<span class="token comment" spellcheck="true">#节点名称，必须不一样</span><span class="token key atrule">node.name</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span><span class="token number">3</span><span class="token comment" spellcheck="true">#必须为本机的ip地址</span><span class="token key atrule">network.host</span><span class="token punctuation">:</span> 127.0.0.1<span class="token comment" spellcheck="true">#服务端口号，在同一机器下必须不一样</span><span class="token key atrule">http.port</span><span class="token punctuation">:</span> <span class="token number">9202</span><span class="token comment" spellcheck="true">#集群间通信端口号，在同一机器下必须不一样</span><span class="token key atrule">transport.tcp.port</span><span class="token punctuation">:</span> <span class="token number">9302</span><span class="token comment" spellcheck="true">#设置集群自动发现机器ip集合</span><span class="token key atrule">discovery.zen.ping.unicast.hosts</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"127.0.0.1:9300"</span><span class="token punctuation">,</span><span class="token string">"127.0.0.1:9301"</span><span class="token punctuation">,</span><span class="token string">"127.0.0.1:9302"</span><span class="token punctuation">]</span></code></pre><h3 id="6-2-3-启动各个节点服务器"><a href="#6-2-3-启动各个节点服务器" class="headerlink" title="6.2.3 启动各个节点服务器"></a>6.2.3 启动各个节点服务器</h3><p>双击elasticsearch-cluster\node*\bin\elasticsearch.bat</p><h4 id="启动节点1："><a href="#启动节点1：" class="headerlink" title="启动节点1："></a>启动节点1：</h4><p><img src="image%5C21.png"></p><h4 id="启动节点2："><a href="#启动节点2：" class="headerlink" title="启动节点2："></a>启动节点2：</h4><p><img src="image%5C22.png"></p><h4 id="启动节点3："><a href="#启动节点3：" class="headerlink" title="启动节点3："></a>启动节点3：</h4><p><img src="image%5C23.png"></p><h3 id="6-2-4-集群测试"><a href="#6-2-4-集群测试" class="headerlink" title="6.2.4 集群测试"></a>6.2.4 集群测试</h3><h4 id="添加索引和映射"><a href="#添加索引和映射" class="headerlink" title="添加索引和映射"></a>添加索引和映射</h4><pre class=" language-json"><code class="language-json">PUT        localhost<span class="token operator">:</span><span class="token number">9200</span>/blog1</code></pre><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"mappings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"article"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token property">"id"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"long"</span><span class="token punctuation">,</span>                    <span class="token property">"store"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                    <span class="token property">"index"</span><span class="token operator">:</span><span class="token string">"not_analyzed"</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token property">"title"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>                    <span class="token property">"store"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                    <span class="token property">"index"</span><span class="token operator">:</span><span class="token string">"analyzed"</span><span class="token punctuation">,</span>                    <span class="token property">"analyzer"</span><span class="token operator">:</span><span class="token string">"standard"</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token property">"content"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>                    <span class="token property">"store"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                    <span class="token property">"index"</span><span class="token operator">:</span><span class="token string">"analyzed"</span><span class="token punctuation">,</span>                    <span class="token property">"analyzer"</span><span class="token operator">:</span><span class="token string">"standard"</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档</h4><pre class=" language-json"><code class="language-json">POST    localhost<span class="token operator">:</span><span class="token number">9200</span>/blog1/article/<span class="token number">1</span></code></pre><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"id"</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span><span class="token string">"ElasticSearch是一个基于Lucene的搜索服务器"</span><span class="token punctuation">,</span>    <span class="token property">"content"</span><span class="token operator">:</span><span class="token string">"它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。"</span><span class="token punctuation">}</span></code></pre><h4 id="使用elasticsearch-header查看集群情况"><a href="#使用elasticsearch-header查看集群情况" class="headerlink" title="使用elasticsearch-header查看集群情况"></a>使用elasticsearch-header查看集群情况</h4><p><img src="image%5C62.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <summary type="html">ElasticSearch</summary>
    
    
    
    <category term="全文检索" scheme="http://example.com/categories/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2020/09/28/hello-world/"/>
    <id>http://example.com/2020/09/28/hello-world/</id>
    <published>2020-09-28T02:12:33.872Z</published>
    <updated>2020-09-28T02:12:33.873Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
